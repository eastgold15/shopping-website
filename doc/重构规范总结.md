# 项目重构规范总结

## 概述

本文档总结了在 TypeScript + Elysia + Vue 全栈项目重构过程中建立的规范和最佳实践，特别是基于 users 模块重构的经验。

## 一、API 响应格式统一规范

### 1.1 问题背景
在重构过程中发现部分控制器直接返回对象，而非使用统一的响应格式，导致前端处理不一致。

### 1.2 解决方案
**必须使用 `commonRes` 函数统一 API 响应格式：**

```typescript
// ❌ 错误做法
return { success: true, data: user };

// ✅ 正确做法
return commonRes(user);
```

### 1.3 实施要点
- 所有控制器必须导入 `commonRes` 函数
- 禁止直接返回 `{ success: true, data: ... }` 格式
- 错误处理统一通过自定义错误类抛出

## 二、Service 层错误处理规范

### 2.1 问题背景
原代码中存在方法返回 `null` 的情况，导致前端需要额外处理 null 值，增加了复杂性。

### 2.2 解决方案
**Service 层方法不允许返回 null，必须抛出明确的错误：**

```typescript
// ❌ 错误做法
async getByUsername(username: string): Promise<UserEntity | null> {
    const result = await db.select()...;
    return result || null; // 不允许返回 null
}

// ✅ 正确做法
async getByUsername(username: string): Promise<UserEntity> {
    const result = await db.select()...;
    if (!result) {
        throw new NotFoundError(`用户名为 ${username} 的用户不存在`);
    }
    return result;
}
```

### 2.3 实施要点
- 使用 `NotFoundError`、`ValidationError` 等自定义错误类
- 提供有意义的错误消息
- 控制器层无需额外的 null 检查

## 三、Partner 模式重构规范

### 3.1 模式定义
Partner 模式是指 Service 层方法直接返回数据或抛出错误，不使用包装的响应对象。

### 3.2 重构步骤

#### 步骤1：移除 commonRes 包装
```typescript
// 重构前
async findActiveUsers(): Promise<ServiceResponse<UserEntity[]>> {
    // ...
    return commonRes(users);
}

// 重构后
async getActiveUsers(): Promise<UserEntity[]> {
    // ...
    return users;
}
```

#### 步骤2：方法重命名
遵循更清晰的命名约定：
- `findActiveUsers` → `getActiveUsers`
- `batchUpdateStatus` → `updateStatusBatch`
- `findByEmail` → `getByEmail`

#### 步骤3：更新控制器调用
```typescript
// 重构前
const result = await usersService.findActiveUsers();
return result;

// 重构后
const users = await usersService.getActiveUsers();
return commonRes(users);
```

## 四、数据库和API模型定义规范

### 4.1 目录结构
```
src/
├── db/
│   ├── schema/                  # 数据库表结构定义
│   │   ├── index.schema.ts      # 统一导出
│   │   └── [entity].schema.ts
│   ├── types/                   # 类型转换层
│   │   └── database.typebox.ts  # Drizzle → TypeBox 转换
│   └── connection.ts            # 数据库连接实例
```

### 4.2 数据库Schema定义
- 使用 Drizzle ORM 定义数据库表结构
- 统一的时间戳字段：`createdAt`、`updatedAt`
- 主键使用自增ID：`id: integer('id').primaryKey({ autoIncrement: true })`

### 4.3 类型导出方式（新规范）
**不直接使用 userSchema 导出类型，而是在每个 module 的 model 中创建需要的类型，防止实例化过深**

#### database.types.ts 统一类型转换
```typescript
// 第一步：分别定义所有 insert schemas
const userInsertSchema = createInsertSchema(dbSchema.userSchema, {
  email: t.Optional(t.String({ format: "email" })),
});
const partnersInsertSchema = createInsertSchema(dbSchema.partnersSchema);

// 第二步：分别定义所有 select schemas  
const userSelectSchema = createSelectSchema(dbSchema.userSchema);
const partnersSelectSchema = createSelectSchema(dbSchema.partnersSchema);

// 第三步：组合对象
const insertSchemas = {
  userSchema: userInsertSchema,
  partnersSchema: partnersInsertSchema,
};

const selectSchemas = {
  userSchema: userSelectSchema, 
  partnersSchema: partnersSelectSchema,
};

// 第四步：创建最终的 DbType 对象
export const DbType = {
  typebox: {
    insert: insertSchemas,
    select: selectSchemas,
  },
  spreads: {
    insert: spreads(insertSchemas, "insert"),
    select: spreads(selectSchemas, "select"),
  },
} as const;
```

### 4.4 Model 类型命名规范
**标准命名模式：**
- `CreateXxxDto` - 创建数据传输对象
- `UpdateXxxDto` - 更新数据传输对象  
- `UpdateSortDto` - 排序更新对象
- `XxxQuery` - 查询参数对象
- `XxxModel` - 实体模型类型（提供给前端展示信息的类型）

#### partners.model.ts 示例
```typescript
import { DbType } from "@/db/database.types";
import { Static, t } from "elysia";

// 创建合作伙伴DTO
export const CreatePartnerDto = t.Omit(DbType.typebox.insert.partnersSchema, [
  "id",
  "createdAt", 
  "updatedAt",
]);

// 更新合作伙伴DTO
export const UpdatePartnerDto = t.Partial(
  t.Omit(DbType.typebox.insert.partnersSchema, [
    "id",
    "createdAt",
    "updatedAt", 
  ])
);

// 查询参数
export const PartnerQueryDto = t.Object({
  page: t.Optional(t.Number({ minimum: 1, default: 1 })),
  pageSize: t.Optional(t.Number({ minimum: 1, maximum: 100, default: 10 })),
  search: t.Optional(t.String()),
  name: t.Optional(t.String()),
  isActive: t.Optional(t.Boolean()),
  sortBy: t.Optional(t.String({ default: "sortOrder" })),
  sortOrder: t.Optional(t.Union([t.Literal("asc"), t.Literal("desc")], { default: "asc" })),
});

// 排序更新DTO
export const UpdateSortDto = t.Object({
  sortOrder: t.Number({ minimum: 0 }),
});

// 导出 TypeScript 类型
export type CreatePartnerDto = Static<typeof CreatePartnerDto>;
export type UpdatePartnerDto = Static<typeof UpdatePartnerDto>;
export type PartnerQueryDto = Static<typeof PartnerQueryDto>;
export type UpdateSortDto = Static<typeof UpdateSortDto>;

// 实体模型类型（给前端使用）
export type PartnerModel = Static<typeof DbType.typebox.select.partnersSchema>;
```

## 五、API 模型定义规范

### 5.1 基础模型复用
```typescript
export const userModel = {
  // 直接使用数据库查询类型
  user: DbType.typebox.select.user,
  
  // 使用 Pick 选择需要的字段
  userBasic: t.Pick(DbType.typebox.select.user, ['id', 'username']),
  
  // 使用 Omit 排除不需要的字段
  updateUser: t.Omit(DbType.typebox.insert.user, ['id', 'updatedAt', 'createdAt']),
}
```

### 5.2 路由类型应用
```typescript
export const userRoutes = new Elysia({ prefix: '/users' })
  .model(userModel)  // 注册模型
  .post('/users', async ({ body, usersService }) => {
    const user = await usersService.create(body);
    return commonRes(user);
  }, {
    body: 'updateUser'  // 使用模型中定义的类型
  })
```

## 四、Service层规范

### 4.1 Service层主要特点
**参考 partners.service.ts 的实现模式：**

1. **无需数据验证** - 在 Elysia 的 Controller 已经验证过了
2. **排除结果为null** - 抛出错误而不是返回null
3. **查询返回什么就返回什么** - 不做额外的数据转换
4. **分页返回 {items, meta} 数据格式**
5. **使用 getTableColumns() 获取表字段**

### 4.2 分页返回格式（标准）
**必须按照以下方式实现分页：**

```typescript
// 分页查询实现
async getPartnersList(params: PartnerQueryDto) {
  const {
    page = 1,
    pageSize = 10,
    sortBy = "sortOrder",
    sortOrder = "asc",
    search,
    name,
    isActive,
  } = params;

  // 搜索条件构建
  const conditions = [];
  if (search) {
    conditions.push(
      or(
        like(partnersSchema.name, `%${search}%`),
        like(partnersSchema.description, `%${search}%`),
      ),
    );
  }

  // 构建查询
  const queryBuilder = db
    .select({
      ...this.columns,
      image: imagesSchema.url,
    })
    .from(partnersSchema)
    .leftJoin(imagesSchema, eq(partnersSchema.image_id, imagesSchema.id))
    .orderBy(orderBy);

  // 获取总数
  const totalBuilder = db
    .select({ count: count() })
    .from(partnersSchema);

  if (conditions.length > 0) {
    queryBuilder.where(and(...conditions));
    totalBuilder.where(and(...conditions));
  }

  // 分页
  const offset = (page - 1) * pageSize;
  queryBuilder.limit(pageSize).offset(offset);

  // 并行查询
  const [partners, [{ count: total }]] = await Promise.all([queryBuilder, totalBuilder]);
  
  // 标准分页返回格式
  return {
    items: partners,  // 禁止使用其他字段名
    meta: {
      total,
      page,
      pageSize,
      totalPages: Math.ceil(total / pageSize),
    }
  };
}
```

**重要：分页返回格式禁止使用 `items` 以外的字段名，因为分页返回统一使用这个格式**

### 4.3 错误处理规范
```typescript
// 查询单个实体时，不存在则抛出错误
async getPartnerById(id: number) {
  const partner = await db
    .select({
      ...this.columns,
      image: imagesSchema.url,
    })
    .from(partnersSchema)
    .leftJoin(imagesSchema, eq(partnersSchema.image_id, imagesSchema.id))
    .where(eq(partnersSchema.id, id))
    .limit(1);

  if (!partner.length) {
    throw new NotFoundError(`Partner with id ${id} not found`);
  }

  return partner[0];
}
```

## 五、Controller层规范

### 5.1 命名规范
- **使用 `controller` 命名，不要使用 `route`**
- 文件命名：`xxx.controller.ts`
- 导出命名：`xxxController`

### 5.2 返回格式规范
- **所有Controller必须使用 `commonRes` 返回数据**
- **禁止直接返回对象**

```typescript
// ✅ 正确
return commonRes(result);

// ❌ 错误
return { success: true, data: result };
return result;
```

### 5.3 Model类型使用
**Controller应该使用Model中提供的类型进行验证：**

```typescript
export const partnersController = new Elysia({ prefix: '/partners' })
  .model(partnersModel)  // 注册模型
  .post('/', async ({ body, partnersService }) => {
    const partner = await partnersService.createPartner(body);
    return commonRes(partner);
  }, {
    body: 'CreatePartnerDto'  // 使用模型中定义的类型
  })
  .get('/', async ({ query, partnersService }) => {
    const result = await partnersService.getPartnersList(query);
    return commonRes(result);
  }, {
    query: 'PartnerQueryDto'
  });
```

## 六、重构检查清单

### 6.1 API响应格式检查
- [ ] 所有Controller都导入了 `commonRes`
- [ ] 所有返回都使用 `commonRes(data)` 格式
- [ ] 没有直接返回 `{ success: true, data: ... }` 的情况

### 6.2 Service层错误处理检查
- [ ] 所有可能返回null的方法都改为抛出 `NotFoundError`
- [ ] 方法返回类型去掉了 `| null`
- [ ] Controller中移除了不必要的null检查
- [ ] 分页返回格式使用 `{items, meta}` 结构
- [ ] 禁止使用 `items` 以外的字段名作为数据容器

### 6.3 Model类型定义检查
- [ ] 使用标准命名：`CreateXxxDto`、`UpdateXxxDto`、`XxxQuery`、`XxxModel`
- [ ] 从 `DbType.typebox` 中派生类型，不直接使用schema
- [ ] 导出TypeScript类型供Service和Controller使用
- [ ] 额外导出 `XxxModel` 实体类型给前端使用

### 6.4 Controller命名和结构检查
- [ ] 使用 `controller` 命名，不使用 `route`
- [ ] 文件命名：`xxx.controller.ts`
- [ ] 导出命名：`xxxController`
- [ ] 使用Model中提供的类型进行验证
- [ ] 所有返回都使用 `commonRes`

### 6.5 数据库类型转换检查
- [ ] `database.types.ts` 按步骤组织：分别定义→组合对象→创建DbType
- [ ] 防止实例化过深，不直接从schema导出类型
- [ ] 使用 `spreads` 工具函数处理类型展开

## 七、最佳实践总结

### 7.1 分层职责
- **Service 层**：纯业务逻辑，直接返回数据或抛出错误
- **Controller 层**：处理 HTTP 请求，使用 `commonRes` 包装响应
- **Model 层**：类型定义和验证
- Service层专注业务逻辑，Controller层专注路由和验证

### 7.2 错误处理
- Service 层抛出具体错误
- Controller 层统一错误格式
- 前端统一错误处理

### 7.3 类型安全
- 利用 TypeScript 类型推断
- 使用 TypeBox 进行运行时验证
- 避免 `any` 类型的使用
- 在每个模块的model中定义具体的DTO类型

### 7.4 分页实现标准
- 统一使用 `{items, meta}` 返回格式
- meta包含：`total`、`page`、`pageSize`、`totalPages`
- 支持搜索、排序、过滤参数
- 使用条件构建器动态组装查询
- 使用 `getTableColumns()` 获取表字段
- 并行查询数据和总数：`Promise.all([queryBuilder, totalBuilder])`

## 八、工具和命令

### 8.1 搜索和检查命令
```bash
# 检查是否还有 commonRes 的使用
ripgrep "commonRes" src/modules/user/

# 检查返回格式
ripgrep "return\s+\{\s*success:\s*true" src/modules/user/

# 检查 null 返回
ripgrep "\|\s*null" src/modules/user/

# 搜索route命名（应该改为controller）
grep -r "route" src/modules/

# 搜索分页返回格式不规范的情况
grep -r "return.*{.*data.*:" src/modules/
```

### 8.2 重构验证
```bash
# 验证所有Controller都导入了commonRes
grep -r "import.*commonRes" src/modules/

# 验证Service方法的返回类型
grep -r "): .*| null" src/modules/

# 验证Model类型命名规范
grep -r "export.*Dto\|export.*Query\|export.*Model" src/modules/

# 验证Controller命名
find src/modules -name "*.controller.ts" | wc -l
find src/modules -name "*.route.ts" | wc -l  # 应该为0
```

- 运行类型检查：`npm run type-check`
- 运行测试：`npm run test`
- 代码格式化：`npm run format`

---

**注意**：本规范基于实际重构经验总结，应根据项目发展持续更新和完善。